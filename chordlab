#! /usr/bin/env python
# -*- coding: utf-8 -*-

from optparse import OptionParser
opt = OptionParser(usage="usage: %prog [options] file.chopro ...",
                   version="%prog 0.1 by Rasmus Kaj <kaj@stacken.kth.se>")
opt.add_option("-o", "--output", dest="output", default="result.pdf",
               help="output file to write [default: %default]", metavar="FILE")
(options, sourcefiles) = opt.parse_args()

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4

c = canvas.Canvas(options.output)

margin = 50
ypos = A4[1] - 2*margin/3
xpos = margin
colstart = ypos

def newPage(c) :
    c.showPage()
    c.line(margin, A4[1] - margin/2, A4[0] - margin, A4[1] - margin/2)
    c.line(margin, margin/2, A4[0] - margin, margin/2)
    global ypos
    ypos = A4[1] - margin
    global xpos
    xpos = margin

usedchords = []

knownchords = {
    'A':     [1,  None, 0, 2, 2, 2, 0],
    'Am':    [1,  None, 0, 2, 2, 1, 0],
    'A7':    [1,  None, 0, 2, 0, 2, 0],
    'Am7':   [1,  None, 0, 2, 0, 1, 0],
    'Bb':    [1,  None, 1, 3, 3, 3, 1],
    'Bb':    [1,  None, 1, 3, 3, 3, 1],
    'B':     [2,  None, 1, 3, 3, 3, 1], # TODO: proper bare
    'Bm':    [2,  None, 1, 3, 3, 2, 1], # TODO: proper bare
    'B7':    [2,  None, 1, 3, 1, 3, 1],
    'Bm7':   [2,  None, 1, 3, 1, 2, 1],
    'C':     [1,  None, 3, 2, 0, 1, 0],
    'C7':    [1,  None, 3, 2, 3, 1, 0],
    'Cm':    [3,  None, 1, 3, 3, 2, 1],
    'Cm7':   [3,  None, 1, 3, 1, 2, 1],
    'Cmaj7': [1,  None, 3, 2, 0, 0, 0],
    'C#':    [4,  None, 1, 3, 3, 3, 1],
    'C#7':   [4,  None, 1, 3, 1, 3, 1],
    'C#m':   [4,  None, 1, 3, 3, 2, 1],
    'C#m7':  [4,  None, 1, 3, 1, 2, 1],
    'D':     [1,  None, None, 0, 2, 3, 2],
    'Dm':    [1,  None, None, 0, 2, 3, 1], #?
    'D7':    [1,  None, None, 0, 2, 1, 2], #?
    'Dmaj7': [1,  None, None, 0, 2, 2, 2], #?
    'Dm7':   [1,  None, None, 0, 2, 1, 1], #?
    'E':     [1,  0, 2, 2, 1, 0, 0],
    'Em':    [1,  0, 2, 2, 0, 0, 0],
    'E7':    [1,  0, 2, 2, 1, 3, 0],
    'Em7':   [1,  0, 2, 2, 0, 3, 0],
    'Eadd9': [1,  0, 2, 2, 1, 3, 3],
    'F':     [1,  1, 3, 3, 2, 1, 1],
    'Fm':    [1,  1, 3, 3, 1, 1, 1],
    'F7':    [1,  1, 3, 1, 2, 1, 1],
    'F#':    [2,  1, 3, 3, 2, 1, 1],
    'F#m':   [2,  1, 3, 3, 1, 1, 1],
    'F#7':   [2,  1, 3, 1, 2, 1, 1],
    'F#m7':  [2,  1, 3, 1, 1, 1, 1],
    'G':     [1,  3, 2, 0, 0, 0, 3],
    'G7':    [1,  3, 2, 0, 0, 0, 1],
    'Gm':    [3,  1, 3, 3, 1, 1, 1],
    'G#':    [4,  1, 3, 3, 2, 1, 1],
    'G#m':   [4,  1, 3, 3, 1, 1, 1],
}
localchords = {}

def stringValue(v):
    if v in ('-', 'X', 'x'):
        return None
    else:
        return int(v)

def defineChord(name, *args):
    if args[0] == 'base-fret' and args[2] == 'frets':
        base_fret = int(args[1])
        localchords[name] = [base_fret] + map(stringValue, args[3:])
    else:
        warn("Bad chorddef " + name + ": " + str(args))

def drawChordBox(c, xpos, ypos, chord) :
    dx = 5
    dy = 7
    c.setLineWidth(0.4)
    c.grid([xpos + dx*x for x in range(6)], [ypos + dy*y for y in range(5)])
    c.setStrokeGray(1)
    c.setLineWidth(1)
    c.line(xpos-0.3, ypos, xpos + 5*dx+0.3, ypos)
    c.setStrokeGray(0)
    c.setFont("Helvetica-Oblique", 10)
    c.drawCentredString(xpos + dx*2.5, ypos + 5*dy, chord)
    
    the_chord = None
    if localchords.has_key(chord):
        the_chord = localchords[chord]
    elif  knownchords.has_key(chord):
        the_chord = knownchords[chord]
    
    if the_chord != None:
        c.setFont("Helvetica", 7)
        if the_chord[0] > 1: # bare
            c.drawRightString(xpos-2.0*dx/5, ypos + 3*dy+1, str(the_chord[0]))
        else:
            c.line(xpos-0.2, ypos+4*dy, xpos + 5*dx+0.2, ypos+4*dy)
        x = xpos;
        for string in the_chord[1:]:
            if string == None:
                c.drawCentredString(x, ypos + 4*dy + 1.5, 'x')
            elif string == 0:
                c.drawCentredString(x, ypos + 4*dy + 1.5, 'o')
            else:
                c.circle(x, ypos + (4.5-string)*dy, 2.0*dx/5, stroke=0, fill=1)
        
            x += dx

def drawChordBoxes(c) :
    global usedchords
    usedchords.sort()
    xpos = margin;
    for chord in usedchords:
        drawChordBox(c, xpos, 4*margin/5, chord);
        xpos += 40
    usedchords = []
    
def useChord(chord) :
    global usedchords
    if not chord in ['N.C.', '%', ''] + usedchords :
        usedchords.append(chord)
        if not (knownchords.has_key(chord) or localchords.has_key(chord)) :
            warn("Unknown chord: " + chord)

def newSong(c) :
    drawChordBoxes(c)
    global localchords
    localchords = {}
    newPage(c)
    global colw
    global prevfile
    colw = A4[0]
    prevfile = fileinput.filename()
    # print prevfile

import re
statement = re.compile('{([a-z_]+)(: *(.*))?}')
chordre = re.compile('\[([^]]*)\]')

socpos = [0,0]


import fileinput

def doColumnBreak() :
    global ypos
    global xpos
    global colstart
    ypos = colstart
    xpos += colw
    if (xpos + 1 > A4[0] - margin) :
        newPage(c)

def warn(msg) :
    print fileinput.filename() + ':' + str(fileinput.filelineno()), msg
    

prevfile = None
for line in fileinput.input(sourcefiles, 
                            openhook=fileinput.hook_encoded("iso-8859-1")):
    if prevfile != fileinput.filename():
        newSong(c)
        
    line = line.rstrip()
    m = statement.match(line)
    if m :
        stmt = m.group(1);
        if stmt in ('t', 'title'):
            c.setFont("Times-Bold", 14);
            ypos -= 6
            c.drawCentredString(A4[0]/2, ypos, m.group(3))
            
        elif stmt in ('st', 'subtitle'):
            c.setFont("Times-Roman", 12);
            ypos -= 14
            c.drawCentredString(A4[0]/2, ypos, m.group(3))
            
        elif stmt in ('c', 'comment', 'ci'):
            c.setFont("Times-Italic", 10)
            ypos -= 12
            c.drawString(xpos, ypos, m.group(3))
            
        elif stmt in ('soc', 'start_of_chorus'):
            socpos = [xpos-5, ypos]
            xpos += 10
            
        elif stmt in ('eoc', 'end_of_chorus'):
            xpos -= 10
            c.line(socpos[0], socpos[1], xpos-5, ypos-5)

        elif stmt in ('col', 'cols', 'columns'):
            coln = int(m.group(3))
            colw = (A4[0] - 2*margin) / coln
            colstart = ypos
            # print "Pagew:", A4[0] - 2*margin, "cols:", coln, "colw:", colw
            
        elif stmt in ('colb', 'column_break'):
            doColumnBreak()
                
        elif stmt in ('np', 'new_page'):
            newPage(c)
            
        elif stmt == 'new_song':
            newSong(c)
            
        elif stmt == 'define':
            defineChord(*m.group(3).split())
            
        elif stmt == 'no_grid':
            # TODO no chord grids for this song!
            pass
        
        else:
            warn("Unknown statement: " + m.group(1) + " param: " + str(m.group(3)))
    
    elif len(line) == 0 :
        ypos -= 16
    
    elif line[0] != '#' :
        
        if ypos < margin + 20:
            doColumnBreak()
        ypos -= 24
            
        to = c.beginText(xpos, ypos)
        ischord = 0
        okpos = 0
        for x in chordre.split(line) :
            if ischord :
                useChord(x)
                csp = to.getCursor()
                while csp[0] < okpos :
                    to.textOut(u'\u00B7')
                    csp = to.getCursor()
                to.setFont("Helvetica-Oblique", 10)
                to.setRise(11)
                to.setFillGray(0.5)
            else:
                to.setFont("Times-Roman", 12)
                to.setRise(0)
                to.setFillGray(0)
            to.textOut(x)
            if ischord :
                okpos = to.getCursor()[0]
                to.setTextOrigin(csp[0], csp[1])
            ischord = not(ischord);
        c.drawText(to)

drawChordBoxes(c)
c.showPage()
c.save()
