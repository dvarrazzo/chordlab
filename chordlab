#! /usr/bin/env python
# -*- coding: utf-8 -*-

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4

class CanvasAdapter(canvas.Canvas) :
    "My convenience adapter for the reportlab canvas."
    
    def __init__(self, filename, pagesize=A4, margin=50, showfilenames=False,
                 duplex=True):
        canvas.Canvas.__init__(self, filename, pagesize=pagesize)
        self.pagesize = pagesize
        self.margin = margin
        self.showfilenames = showfilenames
        self.duplex = duplex
        self.pageno = 0
        self.top = self.pagesize[1] - 0.4*self.margin
        self.bottom = 0.62*self.margin
        self.left = 0.5 * self.margin
        self.right = self.pagesize[0] - 1.5 * self.margin

    def newPage(self, filename) :
        if self.pageno > 0: self.showPage()
        self.pageno += 1
        if self.duplex and (self.pageno % 2 == 1):
            self.left = 1.5 * self.margin
            self.right = self.pagesize[0] - 0.5 * self.margin
            self.setFont('Times-Roman', 9)
            self.drawRightString(self.right, self.bottom - 9, str(self.pageno))
        else:
            self.left = 0.5 * self.margin
            self.right = self.pagesize[0] - 1.5 * self.margin
            self.setFont('Times-Roman', 9)
            self.drawString(self.left, self.bottom - 9, str(self.pageno))
        self.line(self.left, self.top, self.right, self.top)
        self.line(self.left, self.bottom, self.right, self.bottom)
        if self.showfilenames:
            self.setFont('Helvetica', 8)
            self.drawString(self.left, self.bottom - 9, filename)
        return (self.left, self.top)
    
    def get_left(self) :
        "Get left start of drawable area"
        return self.left

    def get_right(self) :
        "Get right end of drawable area"
        return self.right

    def get_top(self) :
        "Get top start of drawable area"
        return self.top

    def get_bottom(self) :
        "Get top end of drawable area"
        return self.bottom

from optparse import OptionParser

description = """Takes a set of chopro files and converts them to a single
pdf file.  If no file names are given as arguments, a single chopro files
is read from stdin.  Chopro files is simply text files with chord names in
brackets and some other options in braces, on separate lines."""

opt = OptionParser(usage="usage: %prog [options] file.chopro ...",
                   version="%prog 0.1 by Rasmus Kaj <kaj@stacken.kth.se>",
                   description=description)
opt.add_option("-o", "--output", dest="output", default="chords.pdf",
               help="output file to write [default: %default]", metavar="FILE")
opt.add_option("--showfilenames",
               action="store_true", dest="showfiles", default=False,
               help="Show source filenames in output")
(options, sourcefiles) = opt.parse_args()

usedchords = []

knownchords = {
    'Ab':    [4,  1, 3, 3, 2, 1, 1],
    'Abm':   [4,  1, 3, 3, 1, 1, 1],
    'Ab7':   [4,  1, 3, 1, 2, 1, 1],
    'Abm7':  [4,  1, 3, 1, 1, 1, 1],
    'A':     [1,  None, 0, 2, 2, 2, 0],
    'Am':    [1,  None, 0, 2, 2, 1, 0],
    'A7':    [1,  None, 0, 2, 0, 2, 0],
    'Am7':   [1,  None, 0, 2, 0, 1, 0],
    'Asus2': [1,  None, 0, 2, 2, 0, 0],
    'Bb':    [1,  None, 1, 3, 3, 3, 1],
    'Bbm':   [1,  None, 1, 3, 3, 2, 1],
    'Bb7':   [1,  None, 1, 3, 1, 3, 1],
    'Bbm7':  [1,  None, 1, 3, 1, 2, 1],
    'B':     [2,  None, 1, 3, 3, 3, 1],
    'Bm':    [2,  None, 1, 3, 3, 2, 1],
    'B7':    [2,  None, 1, 3, 1, 3, 1],
    'Bm7':   [2,  None, 1, 3, 1, 2, 1],
    'H':     [2,  None, 1, 3, 3, 3, 1],
    'Hm':    [2,  None, 1, 3, 3, 2, 1],
    'H7':    [2,  None, 1, 3, 1, 3, 1],
    'Hm7':   [2,  None, 1, 3, 1, 2, 1],
    'C':     [1,  None, 3, 2, 0, 1, 0],
    'C7':    [1,  None, 3, 2, 3, 1, 0],
    'Cm':    [3,  None, 1, 3, 3, 2, 1],
    'Cm7':   [3,  None, 1, 3, 1, 2, 1],
    'Cmaj7': [1,  None, 3, 2, 0, 0, 0],
    'C#':    [4,  None, 1, 3, 3, 3, 1],
    'C#7':   [4,  None, 1, 3, 1, 3, 1],
    'C#m':   [4,  None, 1, 3, 3, 2, 1],
    'C#m7':  [4,  None, 1, 3, 1, 2, 1],
    'D':     [1,  None, None, 0, 2, 3, 2],
    'Dm':    [1,  None, None, 0, 2, 3, 1], #?
    'D7':    [1,  None, None, 0, 2, 1, 2], #?
    'Dmaj7': [1,  None, None, 0, 2, 2, 2], #?
    'Dm7':   [1,  None, None, 0, 2, 1, 1], #?
    'Eb':    [3,  None, 4, 3, 1, 2, 1],
    'E':     [1,  0, 2, 2, 1, 0, 0],
    'Em':    [1,  0, 2, 2, 0, 0, 0],
    'E7':    [1,  0, 2, 2, 1, 3, 0],
    'Em7':   [1,  0, 2, 2, 0, 3, 0],
    'Emaj7': [1,  0, 2, 1, 1, 0, 0],
    'Eadd9': [1,  0, 2, 2, 1, 3, 3],
    'F':     [1,  1, 3, 3, 2, 1, 1],
    'Fm':    [1,  1, 3, 3, 1, 1, 1],
    'F7':    [1,  1, 3, 1, 2, 1, 1],
    'Fmaj7': [1,  1, 3, 2, 2, 1, 1],
    'F#':    [2,  1, 3, 3, 2, 1, 1],
    'F#m':   [2,  1, 3, 3, 1, 1, 1],
    'F#7':   [2,  1, 3, 1, 2, 1, 1],
    'F#m7':  [2,  1, 3, 1, 1, 1, 1],
    'G':     [1,  3, 2, 0, 0, 0, 3],
    'G7':    [1,  3, 2, 0, 0, 0, 1],
    'Gm':    [3,  1, 3, 3, 1, 1, 1],
    'Gm7':   [3,  1, 3, 1, 1, 1, 1],
    'G#':    [4,  1, 3, 3, 2, 1, 1],
    'G#7':   [4,  1, 3, 1, 2, 1, 1],
    'G#m':   [4,  1, 3, 3, 1, 1, 1],
    'G#m7':  [4,  1, 3, 1, 1, 1, 1],
}
localchords = {}

def stringValue(v):
    if v in ('-', 'X', 'x'):
        return None
    else:
        return int(v)

def defineChord(name, *args):
    if args[0] == 'base-fret' and args[2] == 'frets':
        base_fret = int(args[1])
        localchords[name] = [base_fret] + map(stringValue, args[3:])
    else:
        warn("Bad chorddef " + name + ": " + str(args))

def drawChordBox(c, xpos, ypos, chord) :
    dx = 5
    dy = 7
    c.setLineWidth(0.4)
    c.grid([xpos + dx*x for x in range(6)], [ypos + dy*y for y in range(5)])
    c.setStrokeGray(1)
    c.setLineWidth(1)
    c.line(xpos-0.3, ypos, xpos + 5*dx+0.3, ypos)
    c.setStrokeGray(0)
    c.setFont("Helvetica-Oblique", 10)
    c.drawCentredString(xpos + dx*2.5, ypos + 5*dy, chord)
    
    the_chord = None
    if localchords.has_key(chord):
        the_chord = localchords[chord]
    elif  knownchords.has_key(chord):
        the_chord = knownchords[chord]
    
    if the_chord != None:
        c.setFont("Helvetica", 7)
        if the_chord[0] > 1: # bare
            c.drawRightString(xpos-2.0*dx/5, ypos + 3*dy+1, str(the_chord[0]))
        else:
            c.line(xpos-0.2, ypos+4*dy, xpos + 5*dx+0.2, ypos+4*dy)
        x = xpos;
        for string in the_chord[1:]:
            if string == None:
                c.drawCentredString(x, ypos + 4*dy + 1.5, 'x')
            elif string == 0:
                c.drawCentredString(x, ypos + 4*dy + 1.5, 'o')
            else:
                c.circle(x, ypos + (4.5-string)*dy, 2.0*dx/5, stroke=0, fill=1)
        
            x += dx

skip_grid = False

def drawChordBoxes(c) :
    global skip_grid
    if skip_grid:
        skip_grid = False
        return
    boxw = 37
    global usedchords
    usedchords.sort()
    xpos = c.get_right() - len(usedchords) * boxw + boxw - 5*5;
    ypos = c.get_bottom() + 8
    for chord in usedchords:
        drawChordBox(c, xpos, ypos, chord);
        xpos += boxw
    usedchords = []
    
def useChord(chord) :
    global usedchords
    p = re.compile('\(.*\)')
    chord = p.sub('', chord)
    if not chord in ['N.C.', '%', '-', ''] + usedchords :
        usedchords.append(chord)
        if not (knownchords.has_key(chord) or localchords.has_key(chord)) :
            warn("Unknown chord: " + chord)

def newSong(c) :
    drawChordBoxes(c)
    global localchords
    localchords = {}
    global prevfile
    prevfile = fileinput.filename()
    (x, y) = c.newPage(prevfile)
    global colw
    colw = c.get_right() # Any large number, really
    return (x, y)

# -- main --
c = CanvasAdapter(options.output, showfilenames=options.showfiles)

import re
statement = re.compile('{([a-z_]+)(:? *(.*))?}')
chordre = re.compile('\[([^]]*)\]')

socpos = [0,0]


import fileinput

colstart = 0

def doColumnBreak() :
    global xpos
    global ypos
    global colstart
    ypos = colstart
    xpos += colw
    if (xpos + 1 > c.get_right()) :
        (xpos, ypos) = c.newPage(fileinput.filename())
    global tabmode
    if tabmode:
        c.setFont("Courier", 9);
        

def warn(msg) :
    print fileinput.filename() + ':' + str(fileinput.filelineno()), msg
    
tabmode = 0

prevfile = None
for line in fileinput.input(sourcefiles, 
                            openhook=fileinput.hook_encoded("iso-8859-1")):
    if prevfile != fileinput.filename():
        (xpos, ypos) = newSong(c)
        
    line = line.rstrip()
    m = statement.match(line)
    if m :
        stmt = m.group(1);
        if stmt in ('t', 'title'):
            c.setFont("Times-Bold", 14);
            ypos -= 18
            c.drawCentredString((c.get_left() + c.get_right())/2, ypos, m.group(3))
            
        elif stmt in ('st', 'subtitle'):
            c.setFont("Times-Roman", 12);
            ypos -= 14
            c.drawCentredString((c.get_left() + c.get_right())/2, ypos, m.group(3))
            
        elif stmt in ('c', 'comment', 'ci'):
            c.setFont("Times-Italic", 10)
            ypos -= 12
            c.drawString(xpos, ypos, m.group(3))
            
        elif stmt in ('soc', 'start_of_chorus'):
            socpos = [xpos-5, ypos]
            xpos += 10
            
        elif stmt in ('eoc', 'end_of_chorus'):
            xpos -= 10
            c.line(socpos[0], socpos[1], xpos-5, ypos-5)

        elif stmt in ('sot'):
            c.setFont("Courier", 9);
            tabmode = 1
            
        elif stmt in ('eot'):
            tabmode = 0
            
        elif stmt in ('col', 'cols', 'columns'):
            coln = int(m.group(3))
            colw = (c.get_right() - c.get_left()) / coln
            colstart = ypos
            # print "Pagew:", A4[0] - 2*margin, "cols:", coln, "colw:", colw
            
        elif stmt in ('colb', 'column_break'):
            doColumnBreak()
                
        elif stmt in ('np', 'new_page'):
            (xpos, ypos) = c.newPage(fileinput.filename())
            
        elif stmt == 'new_song':
            (xpos, ypos) = newSong(c)
            
        elif stmt == 'define':
            defineChord(*m.group(3).split())
            
        elif stmt in ('ng', 'no_grid'):
            skip_grid = True
        
        else:
            warn("Unknown statement: " + m.group(1) + " param: " + str(m.group(3)))
    
    elif len(line) == 0 :
        ypos -= 16
    
    elif line[0] == '#':
        pass
    
    elif tabmode:
        if ypos < c.get_bottom() + 12:
            doColumnBreak()
        ypos -= 9
        c.drawString(xpos, ypos, line)
        
    else:
        if ypos < c.get_bottom() + 24:
            doColumnBreak()
        ypos -= 22
        
        to = c.beginText(xpos, ypos)
        ischord = 0
        okpos = 0
        for x in chordre.split(line) :
            if ischord :
                useChord(x)
                csp = to.getCursor()
                while csp[0] < okpos :
                    to.textOut(u'\u00B7')
                    csp = to.getCursor()
                to.setFont("Helvetica-Oblique", 9)
                to.setRise(11)
                to.setFillGray(0.5)
            else:
                to.setFont("Times-Roman", 12)
                to.setRise(0)
                to.setFillGray(0)
            to.textOut(x)
            if ischord :
                okpos = to.getCursor()[0] + 1
                to.setTextOrigin(csp[0], csp[1])
            ischord = not(ischord);
        c.drawText(to)

drawChordBoxes(c)
c.showPage()
c.save()
